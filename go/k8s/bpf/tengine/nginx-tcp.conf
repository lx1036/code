
# https://www.nginx.com/resources/wiki/start/topics/examples/full/
# ./objs/nginx -c ./nginx-tcp.conf -p . -e stderr

worker_processes  1;
daemon off;
# only-master 模式，只有 master 进程
master_process off;
error_log stderr notice;

events {
    worker_connections  1024;
}
 
# http {
#     server {
#  	  listen 9090;
#  	  location / {
            ## 不要 proxy_set_header Host $host; 这个指令容易被 redirect 到 $host:80，比如 openstack dashboard
# 			proxy_set_header Host $host;
#         	proxy_set_header  X-Real-IP        $remote_addr;
#         	proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;
#         	proxy_set_header X-NginX-Proxy true;
# 			rewrite ^/(.*)$ /$1 break;
#    			proxy_pass http://127.0.0.1;
#  		}
#  	}
# }


stream {
    # http://nginx.org/en/docs/stream/ngx_stream_log_module.html
    # log_format basic '$binary_remote_addr $bytes_received $bytes_sent $connection'
#     # access_log  logs/access.log  main;
    # access_log stderr basic; 

#     # 这里需要加上 openresty 路径，否则报错 "module 'resty.core' not found"
#     # lua_package_path "/usr/local/Cellar/openresty/1.21.4.2_1/lualib/?.lua;;";
#     # lua_package_cpath "/usr/local/Cellar/openresty/1.21.4.2_1/lualib/?.so;;";

    # server {
    #     # listen 4001 udp reuseport;
    #     # proxy_connect_timeout 1s;
    #     # proxy_timeout 3s;

    #     # 启动 http server `python2 -m SimpleHTTPServer 4002`
    #     # proxy_pass 127.0.0.1:9091;

    #     # https://github.com/openresty/stream-lua-nginx-module
    #     # content_by_lua_block 会拦截 proxy_pass 使得其无效，返回 "hello world from lua block"
    #     # content_by_lua_block {
    #     #     ngx.say("hello world from lua block") -- output data
    #     # }
    #     # log_by_lua_block {
    #     #     ngx.log(ngx.INFO, "log_by_lua*")
    #     # }
    # }

    # `nc -v localhost 5001` 命令来 tcp 访问，如果是 proxy_pass 到 http，则只能 `curl localhost:5001`
    server {
        listen 5001;
        return "hello world";
    }

    # `echo "hello" | nc -uvw1 localhost 5002`
    # `echo "hello" | nc -uw1 localhost 5002`, 首选这个，只发一次 udp 请求报文
    # `nc -uvw1 localhost 5002`
    server {
        listen 5002 udp;
        return "hello world";
    }

    # echo "PROXY TCP4 127.0.0.1 127.0.0.1 12345 5003\r\nhello world" | nc localhost 5003
    # 这里配置 client->listen 5003(支持解析 proxy-protocol)，见文档
    # https://docs.nginx.com/nginx/admin-guide/load-balancer/using-proxy-protocol/#configuring-nginx-to-accept-the-proxy-protocol
    # 对于 client -> listen 5003 -> proxy upstream, 这个链路时 listen 5003 -> proxy upstream 支持解析 proxy-protocol，然后发报文给 upstream 也带上 proxy-protocol，可以见文档
    # https://docs.nginx.com/nginx/admin-guide/load-balancer/using-proxy-protocol/#proxy-protocol-for-a-tcp-connection-to-an-upstream
    server {
        listen 5003 proxy_protocol;
        # notice
        error_log stderr debug;
        
        # 加上变量
        return "hello $proxy_protocol_addr:$proxy_protocol_port";
    }

    # proxy upstream 支持 proxy-protocol
    # echo "PROXY TCP4 127.0.0.1 127.0.0.1 23456 5004\r\nhello world" | nc localhost 5004
    # 打开多个 Wireshark 实例: `open -n /Applications/Wireshark.app`
    server {
        listen 5004 proxy_protocol;

        # localhost:12345 需要解析 proxy-protocol 报文, `python3 proxy_protocol_tcp_server.py`
        proxy_pass          localhost:12345;
        proxy_protocol      on;
    }

#     # upstream python_server {
#     #     # http://nginx.org/en/docs/stream/ngx_stream_upstream_module.html#hash
#     #     # 实现负载均衡算法: hash 和 一致性hash
#     #     hash $remote_addr consistent;
#     #     # http://nginx.org/en/docs/stream/ngx_stream_upstream_module.html#least_conn
#     #     # 实现负载均衡算法: 最少链接数
#     #     least_conn;
#     #     server 127.0.0.1:4002 weight=5;
#     #     server 127.0.0.1:4003 backup;
#     # }
}

