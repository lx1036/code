package loader

import (
	"bufio"
	"bytes"
	"context"
	"fmt"
	log "github.com/sirupsen/logrus"
	"io"
	"io/ioutil"
	"k8s.io/klog/v2"
	"os"
	"os/exec"
	"path"

	"k8s-lx1036/k8s/network/cilium/cilium/pkg/config/option"
)

// OutputType determines the type to be generated by the compilation steps.
type OutputType string

const (
	outputObject   = OutputType("obj")
	outputAssembly = OutputType("asm")
	outputSource   = OutputType("c")
)

const (
	compiler = "clang"
	linker   = "llc"
)

var (
	standardLDFlags = []string{"-march=bpf"}
)

// progInfo describes a program to be compiled with the expected output format
type progInfo struct {
	// Source is the program source (base) filename to be compiled
	Source string
	// Output is the expected (base) filename produced from the source
	Output string
	// OutputType to be created by LLVM
	OutputType OutputType
}

// directoryInfo includes relevant directories for compilation and linking
type directoryInfo struct {
	// Library contains the library code to be used for compilation
	Library string
	// Runtime contains headers for compilation
	Runtime string
	// State contains node, lxc, and features headers for templatization
	State string
	// Output is the directory where the files will be stored
	Output string
}

// Compile compiles a BPF program generating an object file.
func Compile(ctx context.Context, src string, out string) error {
	debug := option.Config.BPFCompilationDebug
	prog := progInfo{
		Source:     src,
		Output:     out,
		OutputType: outputObject,
	}
	dirs := directoryInfo{
		Library: option.Config.BpfDir,
		Runtime: option.Config.StateDir,
		Output:  option.Config.StateDir,
		State:   option.Config.StateDir,
	}
	return compile(ctx, &prog, &dirs, debug)
}

// compile and link a program.
func compile(ctx context.Context, prog *progInfo, dir *directoryInfo, debug bool) (err error) {
	args := make([]string, 0, 16)
	if prog.OutputType == outputSource {
		args = append(args, "-E") // Preprocessor
	} else {
		args = append(args, "-emit-llvm", "-g")
	}

	switch prog.OutputType {
	case outputSource:
		compileCmd := exec.CommandContext(ctx, compiler, args...)
		_, err = compileCmd.CombinedOutput()
	case outputObject:
		err = compileAndLink(ctx, prog, dir, true, args...)
	case outputAssembly:
		err = compileAndLink(ctx, prog, dir, false, args...)
	default:
		klog.Fatalf("Unhandled progInfo.OutputType %s", prog.OutputType)
	}

	return err
}

// INFO: clang -O2 -g -Wall -target bpf -emit-llvm -c xdp-example.c -o xdp-example.bc -| llc xdp-example.bc -march=bpf -mattr=dwarfris -filetype=obj -o xdp-example.o
//  这个 Compile 逻辑，以后 BPF 可以直接复用就行
func compileAndLink(ctx context.Context, prog *progInfo, dir *directoryInfo, debug bool, compileArgs ...string) error {
	compileCmd := exec.CommandContext(ctx, compiler, compileArgs...)
	compilerStdout, compilerStderr, err := prepareCmdPipes(compileCmd)
	if err != nil {
		return err
	}

	var compileOut []byte
	linkArgs := make([]string, 0, 8)
	if debug {
		linkArgs = append(linkArgs, "-mattr=dwarfris")
	}
	linkArgs = append(linkArgs, standardLDFlags...)
	linkArgs = append(linkArgs, "-mcpu="+GetBPFCPU())
	linkArgs = append(linkArgs, progLDFlags(prog, dir)...)
	linkCmd := exec.CommandContext(ctx, linker, linkArgs...)
	linkCmd.Stdin = compilerStdout
	_, err = linkCmd.CombinedOutput()
	if err == nil {
		compileOut, _ = ioutil.ReadAll(compilerStderr)
		err = compileCmd.Wait()
	}

	if err != nil {
		klog.Errorf(fmt.Sprintf("Failed to compile %s: %v", prog.Output, err))
		log.WithFields(log.Fields{
			"compiler-pid": pidFromProcess(compileCmd.Process),
			"linker-pid":   pidFromProcess(linkCmd.Process),
		}).Error(err)
		if compileOut != nil {
			scopedLog := log.Warn
			if debug {
				scopedLog = log.Debug
			}
			scanner := bufio.NewScanner(bytes.NewReader(compileOut))
			for scanner.Scan() {
				scopedLog(scanner.Text())
			}
		}
	}

	return err
}

func prepareCmdPipes(cmd *exec.Cmd) (io.ReadCloser, io.ReadCloser, error) {
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		return nil, nil, fmt.Errorf("failed to get stdout pipe: %s", err)
	}

	stderr, err := cmd.StderrPipe()
	if err != nil {
		stdout.Close()
		return nil, nil, fmt.Errorf("failed to get stderr pipe: %s", err)
	}

	return stdout, stderr, nil
}

func progLDFlags(prog *progInfo, dir *directoryInfo) []string {
	return []string{
		fmt.Sprintf("-filetype=%s", prog.OutputType),
		"-o", path.Join(dir.Output, prog.Output),
	}
}

func pidFromProcess(proc *os.Process) string {
	result := "not-started"
	if proc != nil {
		result = fmt.Sprintf("%d", proc.Pid)
	}
	return result
}
